//TODO make this into a testable format
public keyWatcher(){
    every(x)miliseconds Do {
        var pressedKey = firmwareCommandQueue(see pressed key);
        var SignalToInterperage = interperateKeyPresses(pressedKey);
        //interperatation is keyinput * 10 + shiftState + (if hold: maxShifts, else 0)
        modeFlow(combineSignalIntoOneNumber(SignalToInterperage));
    }//end loop
}

var oldKey = null;
var holdKeySent; //flag
var shiftState = 0;
var maxShifts = 3;
var holdWaitCount = 0; //TODO implement this where if a press is shorter then this it is normal else it is a hold 
var holdWaitTime = 2; //how long it needs to wait till it can send a hold signal

private interperateKeyPresses(pressedKey){
    var returnValue = null;
    switch(pressedKey){
        case null:
            if(oldKey != null && !holdKeySent && holdWaitCount < holdWaitTime){ // the oldKey is not null and no hold commands where sent out
                if(oldKey == "A"){ //need to take care of shift here due to here being where non-holds are accounted for
                    shiftState = shiftState+1;
                    if(shiftState >= maxShifts){
                        shiftState = 0;
                    }
                }else{
                    returnValue = (oldKey + shiftState);
                    shiftState = 0;
                }
            }//end not after hold check
            holdKeySent = false;
            oldKey = null;
            holdWaitCount = 0;
            break;
        case oldKey:
            if(pressedKey == null){
                break;
            }
            if(holdWaitCount < holdWaitTime){
                holdWaitCount = holdWaitCount + 1; 
                break;
            } 
            if(!holdKeySent){
                holdKeySent = true;
                returnValue = (pressedKey + shiftState + hold);
                shiftState = 0;
            } //send out hold key only the one time
            break;
        default:
            oldKey = pressedKey;
            break;
    }//end switch
    return returnValue;
}//end funcutin
   

public sendSpeakerOutput(text){
    var formatedCommand = formatToSpeakerOutput(text);
    firmwareCommandQueue(formatedCommand)
}

//the gates are just mutexes and stuff
private firmwareCommandQueue(command){
    Gate1;
    LockGate1;
    Firmware.sendCommand(command);
    wait till reply
    var reply = Firmware.reply();
    unlockGate1;
    return reply;
}